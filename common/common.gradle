println "DEBUG: Processing common Gradle file"

public class MyBuild extends DefaultTask {
    @TaskAction
    void build() {
        println "DEBUG: Executing the build action for $project"

        // Dummy build action -- put the date and dependency content into each output file
        this.outputs.files.each { output ->
            println "Creating output file $output"
            output.text = new Date()
            project.myConfig.deps.each { depName ->
                println "  Pulling in dependency named $depName"
                def depFile = project.rootProject.allMyOutputs[depName].file
                println "  Dependency == ${depFile.dump()}"
                output.text += "\n$depName :: " + depFile.text
            }
        }
    }

    @InputFiles
    public FileCollection getBuildInputs() {
        // Iterate through each input, so that the dependency on the originating task can be maintained
        FileCollection inputs = project.files([])
        project.myConfig.deps.each { depName ->
            def dep = project.rootProject.allMyOutputs[depName]
            FileCollection depFC = project.files(dep.file) {
                builtBy dep.buildDependencies
            }
            inputs += depFC
        }
        return inputs
    }

    @OutputFiles
    public FileCollection getBuildOutputs() {
        return project.files(project.myConfig.outputs.values()*.file)
    }
}

// Class to use as configuration
class MyConfig {
    List<String> deps = []      // Dependencies identified by name
    Map outputs = [:]           // Outputs identified by name and relative filename
}

class MyPlugin implements Plugin<Project> {
    void apply(Project project) {
        println "DEBUG: Applying MyPlugin to project $project"

        // Add task automatically
        def buildTask = project.task("myBuild", type: MyBuild) {
            group = "MyStuff"
            description = "Sample build task"
        }

        // Add configuration class
        project.extensions.add("myConfig", MyConfig);

        // Process output after configuration has been defined
        project.afterEvaluate {
            println "DEBUG: Project $project has been evaluated"

            // Replace filenames with File objects
            project.myConfig.outputs.each { name, filename ->
                File file = project.files(filename).singleFile

                def artf = project.artifacts.add("myOutputs", [file: file, name: name, type: 'text', builtBy: buildTask])
                project.myConfig.outputs[name] = artf
                println "DEBUG: Artifact == " + artf.dump()
            }

            // Add to a global map of all outputs, so that inputs can be connected later
            project.rootProject.allMyOutputs += project.myConfig.outputs
        }
    }
}

// For the first project, initialize empty map of all outputs
if (!rootProject.ext.has('allMyOutputs'))
    rootProject.ext.allMyOutputs = [:]

// Apply the defined plugin
apply plugin: MyPlugin

// All project have a myOutputs configuration
configurations {
    myOutputs
}
