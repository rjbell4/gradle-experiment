@CacheableTask
public class MyBuild extends DefaultTask {
    @TaskAction
    void build() {
        println "DEBUG: Executing the build action for $project"

        // Dummy build action -- put the path and dependency content into each output file
        outputs.files.each { output ->
            println "Creating output file $output"
            output.text = output.path
            this.getBuildInputs().each { dep ->
                def depFile = dep.get().asFile
                println "  Pulling in dependency named ${depFile.path}"
                output.text += "\n" + depFile.text
            }
        }
    }

    @InputFiles
    public List<RegularFileProperty> getBuildInputs() {
        return project.buildInputProps.collect { k,v -> v }
    }

    @OutputFiles
    public Map<String,RegularFileProperty> getBuildOutputs() {
        return project.buildOutputProps
    }
}

// Class to use as configuration
class MyConfig {
    List<String> buildDeps = []  // Dependencies identified by name
    Map buildOutputs = [:]       // Outputs identified by name and relative filename
}

class MyPlugin implements Plugin<Project> {
    void apply(Project project) {
        project.with {
            // Add task automatically
            def buildTask = task("myBuild", type: MyBuild) {
                group = "MyStuff"
                description = "Sample build task"
            }

            // Add configuration class
            extensions.add("myConfig", MyConfig);

            // Process inputs and outputs after configuration has been defined
            ext.buildOutputProps = [:]
            afterEvaluate {
                // Build map with property for each file
                myConfig.buildOutputs.each { name, filename ->
                    buildOutputProps[name] = buildTask.newOutputFile()
                    buildOutputProps[name].set(layout.buildDirectory.file(filename))
                }

                // Add to a global map of all outputs, so that inputs can be connected later
                if (!rootProject.ext.has('allMyOutputs'))
                    rootProject.ext.allMyOutputs = [:]
                rootProject.allMyOutputs += buildOutputProps

                // Build map with properties for inputs, to be latter matched to outputs
                ext.buildInputProps = myConfig.buildDeps.collectEntries { [(it): buildTask.newInputFile()] }
            }
        }
    }
}

// Map the inputs to outputs once all projects has been evaluated
gradle.projectsEvaluated {
    buildInputProps.each { name, input ->
        if (!rootProject.allMyOutputs.containsKey(name))
            throw new GradleException("The build of project ${project.name} references \"$name\" as an input, but it is never defined as an output by any project")
        buildInputProps[name] = rootProject.allMyOutputs[name]
    }
}

// Apply the defined plugin
apply plugin: MyPlugin
