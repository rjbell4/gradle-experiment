@CacheableTask
public class MyBuild extends DefaultTask {
    @TaskAction
    void build() {
        println "DEBUG: Executing the build action for $project"

        // Dummy build action -- put the path and dependency content into each output file
        outputs.files.each { output ->
            println "Creating output file $output"
            output.text = output.path
            buildInputs.each { dep ->
                def depFile = dep.get().get().asFile
                println "  Pulling in dependency named ${depFile.path}"
                output.text += "\n" + depFile.text
            }
        }
    }

    @InputFiles
    public List<MyFileProvider> getBuildInputs() {
        return project.buildInputProviders
    }

    @OutputFiles
    public Map<String,RegularFileProperty> getBuildOutputs() {
        return project.buildOutputProps
    }
}

// Delayed resolution of a name of a dependecy to a RegularFileProperty,
// allowing it to be mentioned before it is defined
class MyFileProvider implements Provider<RegularFileProperty> {
    String name
    Map map

    public MyFileProvider(String name, Map map) {
        this.name = name
        this.map = map
    }

    public RegularFileProperty get() { return map[name] }
    public RegularFileProperty getOrNull() { return isPresent() ? get() : null }
    public RegularFileProperty getOrElse(RegularFileProperty defaultProp) { return isPresent() ? get() : defaultProp }
    public boolean isPresent() { return map.exists(name) }
    public Provider map(Transformer transformer) { return null }
}

// Class to use as configuration
class MyConfig {
    List<String> buildDeps = []  // Dependencies identified by name
    Map buildOutputs = [:]       // Outputs identified by name and relative filename
}

class MyPlugin implements Plugin<Project> {
    void apply(Project project) {
        project.with {
            // Add task automatically
            def buildTask = task("myBuild", type: MyBuild) {
                group = "MyStuff"
                description = "Sample build task"
            }

            // Add configuration class
            extensions.add("myConfig", MyConfig);

            // Process output after configuration has been defined
            ext.buildOutputProps = [:]
            afterEvaluate {
                // Build list of inputs, which can be resolved later
                ext.buildInputProviders = myConfig.buildDeps.collect { new MyFileProvider(it, rootProject.allMyOutputs) }

                // Build map with properties, instead of filename
                myConfig.buildOutputs.each { name, filename ->
                    buildOutputProps[name] = buildTask.newOutputFile()
                    buildOutputProps[name].set(layout.buildDirectory.file(filename))
                }

                // Add to a global map of all outputs, so that inputs can be connected later
                rootProject.allMyOutputs += buildOutputProps
            }
        }
    }
}

// For the first project, initialize empty map of all outputs
if (!rootProject.ext.has('allMyOutputs'))
    rootProject.ext.allMyOutputs = [:]

// Apply the defined plugin
apply plugin: MyPlugin
